# Dependency Injection with Wire

## Wire Configuration

### 1. Wire File Structure
- Place `wire.go` in the main package directory (e.g., `cmd/usercenter/wire.go`)
- Use `//go:build wireinject` build tag
- Define provider functions for each dependency
- Create `InitializeApp()` function for application setup

### 2. Infrastructure Manager Pattern
```go
// provideInfrastructureManager creates centralized infrastructure manager
func provideInfrastructureManager(cfg *config.Config, logger *zap.Logger) (*infrastructure.Manager, error) {
	return infrastructure.NewManager(cfg, logger)
}

// Extract specific components from manager
func provideGormDB(manager *infrastructure.Manager) *gorm.DB {
	return manager.GetPostgreSQL().DB()
}

func provideCache(manager *infrastructure.Manager) infraCache.Cache {
	return manager.GetRedis()
}

func provideKafkaService(manager *infrastructure.Manager) messaging.Service {
	return manager.GetKafka()
}
```

### 3. Event Publisher Integration
```go
// provideEventPublisher creates event publisher from messaging service
func provideEventPublisher(kafkaService messaging.Service, logger *zap.Logger) publisher.EventPublisher {
	return publisher.NewKafkaEventPublisher(kafkaService.GetProducer(), logger)
}
```

### 4. Wire File Template (Updated)
```go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
	"github.com/zhwjimmy/user-center/internal/events/publisher"
	"github.com/zhwjimmy/user-center/internal/infrastructure"
	"github.com/zhwjimmy/user-center/internal/infrastructure/messaging"
	// Import your packages
)

// InitializeApp creates a new application instance
func InitializeApp() (*server.Server, error) {
	wire.Build(
		// Configuration
		config.Load,
		
		// Logger
		provideLogger,
		
		// Infrastructure Manager
		provideInfrastructureManager,
		
		// Extract connections from manager
		provideGormDB,
		provideCache,
		provideKafkaService,
		
		// Event Publisher
		provideEventPublisher,
		
		// Repositories
		repository.NewUserRepository,
		
		// Services
		service.NewUserService,
		service.NewEventService,
		service.NewAuthService,
		
		// Handlers
		handler.NewUserHandler,
		
		// Server
		provideServer,
	)
	return &server.Server{}, nil
}
```

### 5. Provider Functions
```go
// provideLogger creates a new logger instance
func provideLogger(cfg *config.Config) (*zap.Logger, error) {
	config := zap.NewProductionConfig()
	level, err := zapcore.ParseLevel(cfg.Logging.Level)
	if err != nil {
		level = zapcore.InfoLevel
	}
	config.Level = zap.NewAtomicLevelAt(level)
	return config.Build()
}

// provideGormDB extracts *gorm.DB from infrastructure manager
func provideGormDB(manager *infrastructure.Manager) *gorm.DB {
	return manager.GetPostgreSQL().DB()
}
```

## Main Application Setup

### 1. Main Function Structure
```go
func main() {
	// Initialize application using wire
	app, err := InitializeApp()
	if err != nil {
		fmt.Printf("Failed to initialize application: %v\n", err)
		os.Exit(1)
	}

	// Get logger from server
	log := app.GetLogger()

	log.Info("Starting UserCenter application",
		zap.String("version", Version),
	)

	// Start server in a goroutine
	go func() {
		if err := app.Start(); err != nil {
			log.Fatal("Failed to start server", zap.Error(err))
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
```

### 2. Infrastructure Lifecycle Management
```go
// Server Start method
func (s *Server) Start() error {
	// Start infrastructure components
	if err := s.infra.Start(); err != nil {
		return fmt.Errorf("failed to start infrastructure: %w", err)
	}
	
	// Start HTTP server
	return s.router.Run(s.config.Server.Address)
}

// Server Shutdown method
func (s *Server) Shutdown() error {
	// Stop infrastructure components
	if err := s.infra.Stop(); err != nil {
		return fmt.Errorf("failed to stop infrastructure: %w", err)
	}
	
	return nil
}
```

## Best Practices

### 1. Infrastructure Manager Pattern
- Centralize all external dependency management
- Provide unified lifecycle management (Start/Stop)
- Extract specific components as needed by business layer
- Maintain clean separation between infrastructure and business

### 2. Event Publisher Integration
- Use dependency injection for event publishers
- Publishers wrap infrastructure messaging services
- Business services depend on publisher interfaces, not infrastructure

### 3. Error Handling
- Infrastructure errors should be handled at the manager level
- Business services should receive clean interfaces
- Use proper error wrapping for context

### 4. Testing
- Mock infrastructure manager for testing
- Test business logic with mock publishers
- Use dependency injection for easy mocking

## CI/CD Integration

### 1. Wire Code Generation
- Install Wire tool in CI: `go install github.com/google/wire/cmd/wire@latest`
- Generate code before dependency resolution: `make wire`
- Keep `wire_gen.go` out of version control (in `.gitignore`)

### 2. Makefile Integration
```makefile
.PHONY: wire
wire: ## Generate Wire dependency injection code
	@echo "Generating Wire code..."
	wire ./cmd/usercenter
```

### 3. Common Issues and Solutions

#### Issue: `undefined: InitializeApp`
- **Cause**: Wire code not generated
- **Solution**: Run `make wire` before building
- **Prevention**: Generate in CI before dependency resolution

#### Issue: Circular dependencies
- **Cause**: Providers depend on each other
- **Solution**: Use provider sets or restructure dependencies
- **Example**:
```go
var UserSet = wire.NewSet(
	repository.NewUserRepository,
	service.NewUserService,
	handler.NewUserHandler,
)
```

## Advanced Patterns

### 1. Provider Sets
```